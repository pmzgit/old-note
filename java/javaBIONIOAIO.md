# [基本概念](https://www.cnblogs.com/zingp/p/6863170.html)

## 一、同步和异步说的是消息(io结果)的通知机制，阻塞非阻塞说的是线程的状态
* 同步异步和阻塞非阻塞针对的标的不同。
* JAVA NIO是同步非阻塞io  
client和服务器建立了socket连接：  
1. 同步阻塞io：client在调用read（）方法时，stream里没有数据可读，线程停止向下执行，直至stream有数据。  

阻塞：体现在这个线程不能干别的了，只能在这里等着  
同步：是体现在消息通知机制上的，即stream有没有数据是需要我自己来判断的。  

2. 同步非阻塞io：调用read方法后，如果stream没有数据，方法就返回，然后这个线程就就干别的去了。

非阻塞：体现在，这个线程可以去干别的，不需要一直在这等着  
同步：体现在消息通知机制，这个线程仍然要定时的读取stream，判断数据有没有准备好，client采用循环的方式去读取，可以看出CPU大部分被浪费了  

3. 异步非阻塞io：服务端调用read()方法，若stream中无数据则返回，程序继续向下执行。当stream中有数据时，操作系统会负责把数据拷贝到用户空间，然后通知这个线程，这里的消息通知机制就是异步！而不是像NIO那样，自己起一个线程去监控stream里面有没有数据！

4. I/O多路复用：虽然I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。

5. 阻塞，非阻塞：进程/线程要访问的数据是否就绪，进程/线程是否需要等待；

同步，异步：访问数据的方式，同步需要主动读写数据，在读写数据的过程中还是会阻塞；异步只需要I/O操作完成的通知，并不主动读写数据，由操作系统内核完成数据的读写。

* Java

1. 异步/同步与阻塞/非阻塞之间没有必然的联系

2. 同步IO可以是阻塞，也可以是非阻塞的

3. 异步IO就是异步IO，它一定是非阻塞的，不存在异步阻塞IO这个说法

阻塞与非阻塞式IO的主要区别在于等待数据报准备好（当所有等待分组到达时，它被复制到内核中的某个缓冲区）的第一阶段，第二步就是把数据从内核缓冲区复制到应用程序缓冲区，同步与异步体现在第二步，两者都是同步阻塞的。




## 二、同步、异步、阻塞、非阻塞，是分3个层次的：

CPU层次；  
线程层次；  
程序员感知层次。  
这几个概念之所以容易混淆，是因为没有分清楚是在哪个层次进行讨论。  

在CPU层次，或者说操作系统进行IO和任务调度的层次，现代操作系统通常使用异步非阻塞方式进行IO（有少部分IO可能会使用同步非阻塞轮询），即发出IO请求之后，并不等待IO操作完成，而是继续执行下面的指令（非阻塞），IO操作和CPU指令互不干扰（异步），最后通过中断的方式来通知IO操作完成结果。

线程层次在线程层次，或者说操作系统调度单元的层次，操作系统为了减轻程序员的思考负担，将底层的异步非阻塞的IO方式进行封装，把相关系统调用（如read，write等）以同步的方式展现出来。然而，同步阻塞的IO会使线程挂起，同步非阻塞的IO会消耗CPU资源在轮询上。为了解决这一问题，就有3种思路：多线程（同步阻塞）；IO多路复用（select，poll，epoll）（同步非阻塞，严格地来讲，是把阻塞点改变了位置）；直接暴露出异步的IO接口，如kernel-aio和IOCP（异步非阻塞）。

程序员感知层次在Linux中，上面提到的第2种思路用得比较广泛，也是比较理想的解决方案。然而，直接使用select之类的接口，依然比较复杂，所以各种库和框架百花齐放，都试图对IO多路复用进行封装。此时，库和框架提供的API又可以选择是以同步的方式还是异步的方式来展现。如python的asyncio库中，就通过协程，提供了同步阻塞式的API；如node.js中，就通过回调函数，提供了异步非阻塞式的API。

总结  
因此，我们在讨论同步、异步、阻塞、非阻塞时，必须先明确是在哪个层次进行讨论。比如node.js，我们可以说她在程序员感知层次提供了异步非阻塞的API，也可以说在Linux下，她在线程层次以同步非阻塞的epoll来实现。

阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

# BIO

* 流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。

* IO流的分类  
根据处理数据类型的不同分为：字符流和字节流  
根据数据流向不同分为：输入流和输出流  
基于磁盘操作的I/O接口：File  
基于网络操作的I/O接口：Socket（不在java.io包下）

* 影响IO性能的无非就是两大因素：数据的格式及存储的方式，字节流和字符流主要是数据格式方面的，后两个类是存储方式方面的：本地和网络。

* 字符流和字节流  
字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。   
字节流和字符流的区别：读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。  
处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。  
结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流.是否需要按照指定的编码表，将数据存到文本,则选择InputStreamReader  和 OutputStreamWriter

* 输入流和输出流  
对输入流只能进行读操作，对输出流只能进行写操作，程序中需要根据待传输数据的不同特性而使用不同的流。


* 输入字节流InputStream
    1. InputStream 是所有的输入字节流的父类，它是一个抽象类。  
    2. ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。PipedInputStream 是从与其它线程共用的管道中读取数据，与Piped 相关的知识后续单独介绍。
    3. ObjectInputStream 和所有FilterInputStream 的子类都是装饰流（装饰器模式的主角）。


* 输出字节流OutputStream
    1. OutputStream 是所有的输出字节流的父类，它是一个抽象类。
    2. ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。PipedOutputStream 是向与其它线程共用的管道中写入数据，
    3. ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流。


* LineNumberInputStream 主要完成从流中读取数据时，会得到相应的行号，至于什么时候分行、在哪里分行是由该类主动确定的，并不是在原始中有这样一个行号。在输出部分没有对应的部分，我们完全可以自己建立一个LineNumberOutputStream，在最初写入时会有一个基准的行号，以后每次遇到换行时会在下一行添加一个行号，看起来也是可以的。好像更不入流了。
* PushbackInputStream 的功能是查看最后一个字节，不满意就放入缓冲区。主要用在编译器的语法、词法分析部分。输出部分的BufferedOutputStream 几乎实现相近的功能。
* StringBufferInputStream 已经被Deprecated，本身就不应该出现在InputStream 部分，主要因为String 应该属于字符流的范围。已经被废弃了，当然输出部分也没有必要需要它了！还允许它存在只是为了保持版本的向下兼容而已。
* SequenceInputStream 可以认为是一个工具类，将两个或者多个输入流当成一个输入流依次读取。完全可以从IO 包中去除，还完全不影响IO 包的结构，却让其更“纯洁”――纯洁的Decorator 模式。
* PrintStream 也可以认为是一个辅助工具。主要可以向其他输出流，或者FileInputStream 写入数据，本身内部实现还是带缓冲的。本质上是对其它流的综合运用的一个工具而已。一样可以踢出IO 包！System.out 和System.out 就是PrintStream 的实例！


* 字符输入流Reader  
1. Reader 是所有的输入字符流的父类，它是一个抽象类。
2. CharArrayReader、StringReader 是两种基本的介质流，它们分别将Char 数组、String中读取数据。PipedReader 是从与其它线程共用的管道中读取数据。
3. BufferedReader 很明显就是一个装饰器，它和其子类负责装饰其它Reader 对象。
4. FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader 对象进行装饰，会增加一个行号。
5. InputStreamReader 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader 可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。Reader 中各个类的用途和使用方法基本和InputStream 中的类使用一致

* 字符输出流Writer  
1. Writer 是所有的输出字符流的父类，它是一个抽象类。
2. CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。PipedWriter 是向与其它线程共用的管道中写入数据，
3. BufferedWriter 是一个装饰器为Writer 提供缓冲功能。
4. PrintWriter 和PrintStream 极其类似，功能和使用也非常相似。
5. OutputStreamWriter 是OutputStream 到Writer 转换的桥梁，它的子类FileWriter 其实就是一个实现此功能的具体类（具体可以研究一SourceCode）。功能和使用和OutputStream 极其类似，后面会有它们的对应图。

* 字符流与字节流转换
* InputStreamReader:字节到字符的桥梁
* OutputStreamWriter:字符到字节的桥梁
* 这两个流对象是字符体系中的成员，它们有转换作用，本身又是字符流，所以在构造的时候需要传入字节流对象进来。

* RandomAccessFile类  
该对象并不是流体系中的一员，其封装了字节流，同时还封装了一个缓冲区（字符数组），通过内部的指针来操作字符数组中的数据。 该对象特点：  
    1. 该对象只能操作文件，所以构造函数接收两种类型的参数：a.字符串文件路径；b.File对象。
    2. 该对象既可以对文件进行读操作，也能进行写操作，在进行对象实例化时可指定操作模式(r,rw)
    3. 注意：该对象在实例化时，如果要操作的文件不存在，会自动创建；如果文件存在，写数据未指定位置，会从头开始写，即覆盖原有的内容。 可以用于多线程下载或多个线程同时写数据到文件。  

* 一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作。  
    1. 同步IO和异步IO的区别就在于第二个步骤是否阻塞，如果实际的IO读写阻塞请求进程，那么就是同步IO。
    2. 阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。

* 同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。
* 而阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。
所以,IO操作可以分为3类：同步阻塞（即早期的IO操作）、同步非阻塞（NIO）、异步（AIO）。
1. 同步阻塞：  
    在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式。

2. 同步非阻塞：  
    在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。
3. 异步：  
    此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序。

### java NIO原理及通信模型  
    1. 由一个专门的线程来处理所有的 IO 事件，并负责分发。
    2. 事件驱动机制：事件到的时候触发，而不是同步的去监视事件。
    3. 线程通讯：线程之间通过 wait,notify 等方式通讯。保证每次上下文切换都是有意义的。减少无谓的线程切换。
* 具体可参考：[逸情公子](http://weixiaolu.iteye.com/blog/1479656)
## nio
* [Buffer](http://patchouli-know.com/2016/10/22/java-nio-buffer/gg)
* [Channel](http://patchouli-know.com/2016/10/26/java-nio-channel/#%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F)
* [Selector](http://patchouli-know.com/2016/10/30/java-nio-selector/)
* [java-bio-nio-aio](http://patchouli-know.com/2017/03/18/java-bio-nio-aio/)
