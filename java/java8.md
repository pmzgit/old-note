# [转载自一书生VOID](https://lw900925.github.io/)

## 默认方法，静态方法
* 默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法
* java 可以单继承，多实现，但是在实现多个接口时（接口之间不存在继承关系），多个接口中都存在相同签名的 default 方法时，此时如果需要调用冲突的默认方法时：  
覆写存在歧义的方法，并可以使用 InterfaceName.super.methodName(); 的方式手动调用需要的接口默认方法。
* 当实现类或抽象类实现接口时，子类中与默认方法发生冲突的规则是：  
类的方法声明优先于接口默认方法，无论该方法是具体的还是抽象的,就是@override
* 接口默认方法不能覆写 Object 类的 equals、hashCode 和 toString 方法。
* 虽然 Java 8 的接口的默认方法就像抽象类，能提供方法的实现，但是他们俩仍然是 不可相互代替的：

    * 接口可以被类多实现（被其他接口多继承），抽象类只能被单继承。

    * 接口中没有 this 指针，没有构造函数，不能拥有实例字段（实例变量）或实例方法，无法保存 状态（state），抽象方法中可以。

    * 接口的方法修饰符只有 public 的，这明显也不能满足我们的日常设计
    * 抽象类不能在 java 8 的 lambda 表达式中使用。

* 接口中的静态方法必须是 public 的，public 修饰符可以省略，static 修饰符不能省略。


## [函数式编程初探](http://www.ruanyifeng.com/blog/2012/04/functional_programming.html) 
* https://www.cnblogs.com/webor2006/p/8193855.html
* "函数式编程"是一种"编程范式"（programming paradigm），也就是如何编写程序的方法论。
* 它属于"结构化编程"的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用
### 特点
1. 函数是"第一等公民"

所谓"第一等公民"（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。

2. 只用"表达式"，不用"语句"

"表达式"（expression）是一个单纯的运算过程，总是有返回值；"语句"（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。"语句"属于对系统的读写操作，所以就被排斥在外。当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。

3. 没有"副作用"

所谓"副作用"（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。函数式编程强调没有"副作用"，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。

4. 不修改状态

上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。

在其他类型的语言中，变量往往用来保存"状态"（state）。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。由于使用了递归，函数式语言的运行速度比较慢，这是它长期不能在业界推广的主要原因

5. 引用透明

引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或"状态"，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。

有了前面的第三点和第四点，这点是很显然的。其他类型的语言，函数的返回值往往与系统状态有关，不同的状态之下，返回值是不一样的。这就叫"引用不透明"，很不利于观察和理解程序的行为。

三、意义

1. 代码简洁，开发快速

函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。

2. 接近自然语言，易于理解

函数式编程的自由度很高，可以写出很接近自然语言的代码。  
3. 更方便的代码管理

函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。

4. 易于"并发编程"

函数式编程不需要考虑"死锁"（deadlock），因为它不修改变量，所以根本不存在"锁"线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署"并发编程"（concurrency）。多核CPU是将来的潮流，所以函数式编程的这个特性非常重要。

5. 代码的热升级

函数式编程没有副作用，只要保证接口不变，内部实现是外部无关的。所以，可以在运行状态下直接升级代码，不需要重启，也不需要停机。Erlang语言早就证明了这一点，它是瑞典爱立信公司为了管理电话系统而开发的，电话系统的升级当然是不能停机的。

## [Lambda表达式](https://lw900925.github.io/java/java8-lambda-expression.html)

### what
* 也就是将图书过滤的行为（BookPredicate接口的实现类）当做filter()方法的参数。
* Lambda表达式（lambda expression）是一个匿名函数，由数学中的λ演算而得名。在Java 8中可以把Lambda表达式理解为匿名函数，它没有名称，但是有参数列表、函数主体、返回类型等。
```sh
Lambda表达式的语法如下：
(parameters) -> { statements; }
# 编译器支持类型推断：省略参数类型
```
* 仅有一个抽象方法的接口称为函数式接口
* 以Lambda表达式的方式为函数式接口提供实现。所以可以认为：整个Lambda表达式作为接口的实现类
* **方法（类方法or实例方法）引用**，或者**构造器引用**是Lambda表达式的简便写法.如果你的Lambda表达式只是调用一个方法，最好使用名称调用，而不是描述如何调用，这样可以提高代码的可读性。方法引用使用::分隔符，分隔符的前半部分表示引用类型，后面半部分表示引用的方法名称。例如：Integer::compareTo表示引用类型为Integer，引用名称为compareTo的方法。

### why
* 你可以使用Lambda表达式来重构你的代码，提高代码可读性；使用行为参数化来设计你的程序，让程序更灵活。

* Lambda表达式被封装成了主类的一个私有方法，并通过invokedynamic指令进行调用，在Lambda表达式中this的意义跟在表达式外部完全一样

## [Stream API](https://lw900925.github.io/java/java8-stream-api.html)

### whay
Stream API是对Java中集合操作的增强，可以利用它进行各种过滤、排序、分组、聚合等操作。Stream API配合Lambda表达式可以加大的提高代码可读性和编码效率，Stream API也支持并行操作，我们不用再花费很多精力来编写容易出错的多线程代码了，Stream API已经替我们做好了，并且充分利用多核CPU的优势。借助Stream API和Lambda，开发人员可以很容易的编写出高性能的并发处理程序。
### what
* 流（Stream）类似于关系数据库的查询操作(sql,是一种dsl)，是一种声明式操作。
* 可以把流跟集合做一个比较。在Java中，集合是一种数据结构，或者说是一种容器，用于存放数据，流不是容器，它不关心数据的存放，只关注如何处理。可以把流当做是Java中的Iterator，不过它比Iterator强大多了。流与集合另一个区别在于他们的遍历方式，遍历集合通常使用for-each方式，这种方式称为外部迭代，而流使用内部迭代方式，也就是说它帮你把迭代的工作做了，你只需要给出一个函数来告诉它接下来要干什么
* Stream API将迭代操作封装到了内部，它会自动的选择最优的迭代方式，并且使用并行方式处理时，将集合分成多段，每一段分别使用不同的线程处理，最后将处理结果合并输出。
* 需要注意的是，流只能遍历一次，遍历结束后，这个流就被关闭掉了。如果要重新遍历，可以从数据源（集合）中重新获取一个流。如果你对一个流遍历两次，就会抛出java.lang.IllegalStateException异常
```java
List<String> list = Arrays.asList("A", "B", "C", "D");
Stream<String> stream = list.stream();
stream.forEach(System.out::println);
stream.forEach(System.out::println); // 这里会抛出java.lang.IllegalStateException异常，因为流已经被关闭

```
* 流通常由三部分构成:  
数据源：数据源一般用于流的获取，比如本文开头那个过滤用户的例子中users.stream()方法。  
中间处理：中间处理包括对流中元素的一系列处理，如：过滤（filter()），映射（map()），排序（sorted()）。  
终端处理：终端处理会生成结果，结果可以是任何不是流值，如List<String>；也可以不返回结果，如stream.forEach(System.out::println)就是将结果打印到控制台中，并没有返回。  

* 流创建后，中间操作的时候，可以更改数据源，但执行终点操作的时候,不应该更改数据源。
* 大部分流的操作的参数都是函数式接口,所以Lambda表达式的主体实现应该是无状态的，否则在多线程环境下执行的结果是不确定的。
* 副作用指的是行为参数(Lambda 表达式)在执行的时候有输入输入，比如网络输入输出等。这是因为Java不保证这些副作用对其它线程可见，也不保证相同流管道上的同样的元素的不同的操作运行在同一个线程中。

* why：集合(数组、容器等，但不能是map)->stream-> 集合或单个值或map（reduce 或 collect）https://www.cnblogs.com/CarpenterLee/p/6550212.html


## [Optional类](https://lw900925.github.io/java/java8-optional.html)
## [新的时间和日期API](https://lw900925.github.io/java/java8-newtime-api.html)