# 动态语言和静态语言,强类型语言和弱类型语言,编译型和解释型
* 动态类型语言：是指在运行期间才去做数据类型检查的语言.在用动态语言编程时，不用给变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来
* 静态类型语言的类型判断是在运行前判断（如编译阶段）.静态类型语言为了达到多态会采取一些类型鉴别手段，如继承、接口，而动态类型语言却不需要，所以一般动态语言都会采用dynamic typing，常出现于脚本语言中。
* 静态便于调试，动态方便阅读
* 强类型语言：使之强制数据类型定义的语言。没有强制类型转化前，不允许两种不同类型的变量相互操作。强类型定义语言是类型安全的语言,Java中“int i = 0.0;”是无法通过编译的；
* 弱类型语言：数据类型可以被忽略的语言。与强类型语言相反, 一个变量可以赋不同数据类型的值，允许将一块内存看做多种类型，比如直接将整型变量与字符变量相加。C/C++、PHP都是弱类型语言，比如C++中“int i = 0.0;”是可以编译运行的；
* 强类型语言，类型安全
# 作用域：变量(数据容器)的生命周期 或者 变量的时空访问控制
* 概念  
在java编程中，将变量声明在不同的位置就具有不同的作用域，而作用域的大小则使用{……}来确定，使用{……}可以确定定义的变量的可见性及生命周期。
* 分类
    * 全局作用域
    * 函数作用域（作用域嵌套，例如js）
    * 块级作用域（java）

* 原理或者说实现   
编译

### [js作用域](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)
* 函数级作用域（区别于块级作用域）  
内部的变量，内部都能访问，外部不能访问内部的变量，内部能访问外部的变量，若有相同的变量，采用按执行顺序，就近原则   
**js调用/访问前置,按顺序执行，但是先收集所有定义**  
* 闭包 (返回函数)  
* 理解1


1、一个含有自由变量的函数；   
2、这些自由变量所在的环境。   
外部环境持有内部函数所使用的自由变量，对内部函数形成“闭包”，就这样。 
简单但不严格的说，一个函数的“自由变量”就是既不是参数也不是局部变量的变量。 

一个纯粹（无副作用)的函数如果不含有自由变量，那么每次用相同的参数调用后的得到的结果肯定是一样的。但如果一个函数含有自由变量，那么调用返回的结果不但依赖于参数的值，还依赖于自由变量的值。因此一个含有自由变量的函数要正确执行，必须保证其所依赖的外围环境的存在。 

基于类的面向对象程序语言中有一种情况，就是方法是用的自由变量是来自其所在的类的实例的。像这样：

```java
class Foo {  
    private int x;  
    int AddWith( int y ) { 
        return x + y;
    }  
}  
```

这样的AddWith()有一个参数y和一个自由变量x，其返回的值既依赖于参数的值也依赖于自由变量的值。为了让AddWith()正确工作，它必须依附于Foo的一个实例，不然就得不到x的值了（称为：“变量i未与值相绑定”）。很好理解对吧。不过面向对象的语言里一般不把类称为闭包，没为什么，就是种习惯。 
当然严格来说方法所捕获的自由变量不是x，而是this；x是通过this来访问到的，完整写出应该是this.x。 

如果这个“外围环境”来自一个外围函数，并且内部函数可以作为返回值返回，那么外围函数的局部环境就不能在调用结束时就撤销。也就是说不能在栈上分配空间。 
```js
function AddWith(x) {  
    return function(y) {  
        return x + y  
    }  
}  
```
这样的内部函数有一个参数y和一个自由变量x。x在外围函数AddWith()里是一个参数，也就是一个“已绑定了值的变量”（bound variable）。AddWith()的局部作用域中含有内部函数所使用的自由变量，对内部函数形成闭包。为了让返回出去的内部函数能正常工作，这个内部函数必须依附于一个能提供x的值的环境，也就是AddWith()提供的闭包。这样我们就能够： 
```js
var addFive = AddWith(5)  
var seven = addFive(2) // 2+5=7  
```

全局变量是一种特殊的自由变量。

* 理解2  
使能访问到内部的变量（返回的函数返回了内部的变量） 容易造成内存泄露　　

* this 使用  指当前对象（环境） 的调用者(owner)  闭包时则一般指向window  
由于 javascript的动态性（解释执行，当然也有简单的预编译过程），this的指向在运行时才确定。这个特性在给我们带来迷惑的同时也带来了编程上的 自由和灵活，结合apply(call)方法，可以使JS变得异常强大。

### java 匿名内部类，闭包，lambda 表达式
[匿名内部类](https://www.cnblogs.com/nerxious/archive/2013/01/25/2876489.html)
简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。

故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的。
* [参考](https://zhuanlan.zhihu.com/p/29245059)

* 参考  
https://www.jianshu.com/p/8c0bbd072126  
http://blog.csdn.net/qq_29924041/article/details/53869798  
https://www.jianshu.com/p/efe38b392f53  

openssl smime -sign -in unsigned.mobileconfig -out signed.mobileconfig -signer server.crt -inkey server.key -certfile cert-chain.crt -outform der -nodetach

# Copy-On-Write（读写分离的思想，读和写不同的容器。用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景）
Copy On Write(写时复制) 便是资源管理方面的一种优化技术，广泛的应用于软件开发(如 Java 的 Copy On Write 容器)、虚拟内存管理(如进程的 fork、qemu-kvm 虚拟机镜像乃至 Docker 的 AUFS 文件系统等等。
* fork 之后的父进程和子进程完全共享数据段、代码段、堆和栈等的完全副本，而且内核将共享的地址空间的访问权限改变为只读，如果父进程和紫金陈中的任何一个仕途修改这些区域，则内核职位修改区域的那块内存制作一个副本，通常是虚拟存储系统中的一“页”
* 节省空间、提升效率和更好的支持快照。



# 响应式编程
## what
* 一种基于异步数据流概念的编程模式.
* 数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。

* 响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们的天气app从服务端获取到新的天气数据后，我们需要更新app上展示天气信息的UI；汽车上的车道偏移系统探测到车辆偏移了正常路线就会提醒驾驶者纠正，就是是响应事件。
今天，响应式编程最通用的一个场景是UI：我们的移动App必须做出对网络调用、用户触摸输入和系统弹框的响应。在这个世界上，软件之所以是事件驱动并响应的是因为现实生活也是如此。

## how
* https://www.jianshu.com/p/0cd258eecf60
* http://reactivex.io/


# OGNL是Object-Graph Navigation Language的缩写
* 它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。



# CRLF、CR、LF
CR：Carriage Return，对应ASCII中转义字符\r，表示回车  
LF：Linefeed，对应ASCII中转义字符\n，表示换行  
CRLF：Carriage Return & Linefeed，\r\n，表示回车并换行  

众所周知，Windows操作系统采用两个字符来进行换行，即CRLF；Unix/Linux/Mac OS X操作系统采用单个字符LF来进行换行；另外，MacIntosh操作系统（即早期的Mac操作系统）采用单个字符CR来进行换行。

