# **绪论** `程序 = 数据结构+算法`
* 计算机处理计算问题：数值计算和非数值计算（数据结构）
* 数据：是程序的操作对象，用于描述客观事物
* 数据是信息的载体。它能够被计算机识别、存储和加工处理，是计算机程序加工的"原料"。
随着计算机应用领域的扩大，数据的范畴包括：整数、实数、字符串、图像和声音等。

* 数据元素：组成数据基本单位（eg:二维表中一行记录）
* 数据项：一个数据元素由若干数据项组成（）
* 数据对象：性质相同的数据元素的集合，是数据的子集
* 数据结构：相互之间存在一种或多种特定关系的数据元素的集合，数据结构是数据存在的形式，存在目的是为了提高算法的效率
* （1）线性结构
    线性结构的逻辑特征是：若结构是非空集，则有且仅有一个开始结点和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继。
    线性表是一个典型的线性结构。栈、队列、串等都是线性结构。

    （2）非线性结构
    非线性结构的逻辑特征是：一个结点可能有多个直接前趋和直接后继。数组、广义表、树和图等数据结构都是非线性结构。
* 数据的四种基本结构：
    1. 集合
    2. 线性
    3. 树 （非线性）
    4. 图 （非线性）
* 数据结构研究视角：`1数据逻辑结构`，`2数据存储结构`，`3算法`
    1. 从逻辑关系上描述数据，与存储无关，独立于计算机硬件
    2. 是逻辑结构用计算机语言的实现（映象），依赖于计算机语言 `高级语言`。主要分为  
        1. 顺序存储
        2. 链式存储
        3. 索引
        4. 散列  
        参考：[值得一看的网站](http://student.zjzk.cn/course_ware/data_structure/web/gailun/gailun1.1.2.htm)
    3. 即对数据施加的操作，数据的运算定义在数据的逻辑结构上，与存储、硬件无关，每种逻辑
    结构都有一个运算的集合。例如crud，排序等运算，实际上只是在抽象的数据上所施加的一系列抽
    象的操作
    4. 算法设计依赖逻辑结构，算法实现依赖存储结构
* 算法描述：
    > * 预定义常量和类型
    > * 数据元素类型
    > * 算法函数描述
    > * 赋值语句
    >   1. 简单赋值： 变量名=表达式 `i=1;`
    >   2. 串联赋值：变量名1=变量名2=。。。=表达式 `i=j=k=1;`
    >   3. 成组赋值：（变量名1，变量名2，变量名3）=（表达式1，表达式2，表达式3）  变量名[] = 表达式 `(i,k,k)=(1,2,3)`   `i[] = {1,2,3}`
    >   4. 条件赋值：变量名=条件表达式？表达式1：表达式2 `k=a>1?3:2`
    > * 选择语句 2种
    > * 循环语句 3种
    > * 结束语句
    > * 输入输出语句

* 算法定义：解决特定问题方法，对解题过程准确完整描述。
* 算法特征：
    1. 有穷性：有限长的操作序列
    2. 确定性： 每一个步骤无二义性
    3. 输入：0或多个输入
    4. 输出:1个或多个输出
    5. 可行性
* 算法评估：在计算机资源中，最重要的就是时间和空间，评价算法性能的好坏，实际上就是评估算法的资源占用问题
    1. 算法效率严重依赖于操作数量
    2. 首先关注操作数量的最高次项
    3. 算法空间复杂度：计算算法存储空间来实现
    4. https://trainspott.in/2018/08/03/%E7%99%BD%E8%AF%9D%E7%89%88%E5%A4%A7O%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/
* 时间复杂度：

（1）时间频度 

       一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。

       n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。

（2）时间复杂度

      一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 

      按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),...， k次方阶O(nk),指数阶O(2n)。
      
    O(1)<O(log2n)<O(n)<O(nlog2n)<O(n2)<O(n3)<O(2n)<O(n!)<O(nn)
     算法中语句执行次数为一个常数，则时间复杂度为O(1)
一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记作T(n)，它是该算法问题规模n的函数，时间复杂度主要分析T(n)的数量级。上式中“O”的含义是T(n)的数量级,取f(n)中随n增长最快的项将其系数置为1作为时间复杂度的度量。例如，fi(n) = a * n3 + b * n2 + c * n，则其时间复杂度为O(n3)。算法的时间复杂度不仅依赖于问题的规模n，也取决于待输入数据的性质（如输入数据元素的初始状态）。
（3）时间复杂度的取值

 　　主要用算法时间复杂度的数量级评价一个算法的时间性能。

    最坏时间复杂度是指在最坏情况下，算法的时间复杂度。

    平均时间复杂度是指所有可能输入实例在等概率出现的情况下，算法的期望运行时间。

    最好时间复杂度是指在最好情况下，算法的时间复杂度。

一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。

* 时间复杂度的计算：

1. 计算出基本操作的执行次数T(n) 
    基本操作即算法中的每条语句（以;号作为分割），语句的执行次数也叫做语句的频度。在做算法分析时，一般默认为考虑最坏的情况。

2. 计算出T(n)的数量级 
    求T(n)的数量级，只要将T(n)进行如下一些操作：
    忽略常量、低次幂和最高次幂的系数
    令f(n)=T(n)的数量级。

3. 用大O来表示时间复杂度 
    当n趋近于无穷大时，如果lim(T(n)/f(n))的值为不等于0的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))。

 

一个示例： 
int num1, num2;
for(int i=0; i<n; i++){ 
     num1 += 1;
     for(int j=1; j<=n; j++){ 
         num2 += num1;
     }
} 

分析：
1.
语句int num1, num2;的频度为1；
语句i=0;的频度为1；
语句i<n; i++; num1+=1; j=1; 的频度为n；
语句j<=n; j++; num2+=num1;的频度为n*n；
T(n) = 2 + 4n + 3n*n

2.
忽略掉T(n)中的常量、低次幂和最高次幂的系数
f(n) = n*n = n2

3.
T(n) = O(n2)


在分析一个程序的时间复杂性时，有以下两条规则：

a) 加法规则
T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n)))

b) 乘法规则
T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O( f(n) * g(n) )


* 空间复杂度：

空间复杂度与时间复杂度类似，空间复杂度是指算法在计算机内执行时所需存储空间的度量。记作: S(n)=O(f(n)) 我们一般所讨论的是除正常占用内存开销外的辅助存储单元规模。 

空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。

当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)。
### 常见的数据结构：
集合结构（数据元素之间仅以集合的方式体现，元素之间没有别的关系）  
线性结构（数据元素之间存在一对一的关系）  
树（数据元素之间为一对多或多对一的关系）  
图（数据元素之间为多对多的关系）

# 数组
1. 高级语言 `变量声明` => `类型初始化` => `赋值`
2. https://visualgo.net/zh `可视化`

### 1. 线性表
* 性质  
    1. 元素个数有限
    2. 元素具有逻辑上的顺序性
    3. 元素数据类型相同  

#### 1.1 顺序表
* 特点
    1. 随机访问：通过表头元素地址+元素下标
    2. 缺点-插入和删除：移动大量元素，保证逻辑和物理上连续性
    3. 存储密度大
    4. 在顺序表中，每个结点ai的存储地址是该结点在表中的位置i的线性函数。只要知道基地址和每个结点的大小，就可在相同时间内求出任一结点的存储地址。是一种随机存取结构。LOC（ai）= LOC（a1）+（i-1）*c   1≤i≤n
    5. 顺序表是用向量实现的线性表，向量的下标可以看作结点的相对地址。因此顺序表的的特点是逻辑上相邻的结点其物理位置亦相邻。
* create + insert
```c++
#include <iostream>
#include <cstring>
using namespace std;
class Vector {
private:
    int size, length;
    int *data;
public:
    Vector(int input_size) {
        size = input_size;
        length = 0;
        data = new int[size];
    }
    ~Vector() {
        delete[] data;
    }
    bool insert(int loc, int value) {
        if(loc < 0 || loc > length){
            return false;
        }
        if(length >= size){
            return false;
        }
        for(int i = length; i > loc; --i){
            data[i] = data[i - 1];
        }
        data[loc] = value;
        length++;
        return true;
    }
};
int main() {
    Vector a(2);
    cout << a.insert(1, 0) << endl;
    cout << a.insert(0, 1) << endl;
    cout << a.insert(2, 1) << endl;
    cout << a.insert(1, 2) << endl;
    cout << a.insert(0, 3) << endl;
    return 0;
}
```

1.2 单链表

    * 特点
    1. 链表通过每个结点的链域将线性表的n个结点按其逻辑顺序链接在一起的。
    2. 每个结点只有一个链域的链表称为单链表（Single Linked List）。
    3. 单链表中每个结点的存储地址是存放在其前趋结点next域中，而开始结点无前趋，故应设头指针head指向开始结点。终端结点无后继，故终端结点的指针域为空，即NULL。
    4. 链表由头指针唯一确定，单链表可以用头指针的名字来命名。

* create  
    头插法建表 该方法生成的链表的结点次序与输入顺序相反。

1.2.1 循环链表是一种首尾相接的链表。  
1.2.2 双（向）链表中有两条方向不同的链，即每个结点中除next域存放后继结点地址外，还增加一个指向其直接前趋的指针域prior。    

    * 双链表由头指针head惟一确定的。
    * 带头结点的双链表的某些运算变得方便。
    * 将头结点和尾结点链接起来，为双（向）循环链表。

1.3 栈和队列  
    是两种特殊的线性表，它们的逻辑结构和线性表相同，只是其运算规则较线性表有更多的限制，故又称它们为运算受限的线性表。栈和队列被广泛应用于各种程序设计中。

1.3.1 栈
栈（Stack）是限制仅在表的一端进行插入和删除运算的线性表。  
    
　　* 通常称插入、删除的这一端为栈顶（Top），另一端称为栈底（Bottom）

　　* 当表中没有元素时称为空栈。  

　　* 栈为后进先出（Last In First Out）的线性表，简称为LIFO表。栈的修改是按后进先出的原则进行。每次删除（退栈）的总是当前栈中"最新"的元素，即最后插入（进栈）的元素，而最先插入的是被放在栈的底部，要到最后才能删除。  
    * 元素是以a1，a2，…，an的顺序进栈，退栈的次序却是an，an-1，…，a1。  
    * 分为顺序栈和链栈

1.3.2 队列  
队列（Queue）是只允许在一端进行插入，而在另一端进行删除的运算受限的线性表  

* 允许删除的一端称为队头（Front）。  
* 允许插入的一端称为队尾（Rear）。  
* 当队列中没有元素时称为空队列。  
* 队列亦称作先进先出（First In First Out）的线性表，简称为FIFO表。  
* 队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（即不允许"加塞"），每次离开的成员总是队列头上的（不允许中途离队），即当前"最老的"成员离队。  
* 在队列中依次加入元素a1，a2，…，an之后，a1是队头元素，an是队尾元素。退出队列的次序只能是a1，a2，…，an。
* 顺序队列 队列的顺序存储结构称为顺序队列，顺序队列实际上是运算受限的顺序表。
* 队列的链式存储结构简称为链队列。它是限制仅在表头删除和表尾插入的单链表。

1.4 串  
1.5 多维数组 矩阵  
1.6 树    
* 树形结构是结点之间有分支，并具有层次关系的结构。
 
1.6.1 二叉树   
* 二叉树(BinaryTree)是n(n≥0)个结点的有限集，它或者是空集(n=0)，或者由一个根结点及两棵互不相交的、分别称作这个根的左子树和右子树的二叉树组成。
　　


递归

递归的本质是能把问题拆分成具有相同解决思路的子问题，。。。直到最后被拆解的子问题再也不能拆分，解决了最小粒度可求解的子问题后，在「归」的过程中自然顺其自然地解决了最开始的问题。


## [布隆过滤器](https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md)

```
将数字 A 的第 k 位设置为1：A = A | (1 << (k - 1))
将数字 A 的第 k 位设置为0：A = A & ~(1 << (k - 1))
检测数字 A 的第 k 位：A & (1 << (k - 1)) != 0
```