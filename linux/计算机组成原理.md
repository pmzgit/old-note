## 图灵机
* 可计算性理论
## 冯·诺依曼体系结构
* 运算器、控制器、存储器、输入设备和输出设备

## cpu
* 算术逻辑单元（Arithmetic Logic Unit，ALU）和处理器寄存器（Processor Register）的处理器单元（Processing Unit），用来完成各种算术和逻辑运算。
* 指令寄存器（Instruction Register）和程序计数器（Program Counter）的控制器单元（Control Unit/CU），用来控制程序的流程

## 思维导图
![](./assets/计算机组成原理-思维导图.jpg)

### 性能
性能指标：响应时间 + 吞吐率    
性能定义：1 / 响应时间  
计算机的计时单位：CPU 时钟,程序实际花费的 CPU 执行时间（CPU Time），就是 user time 加上 sys time。(sh: time)  
程序的 CPU 执行时间 = 指令数×CPI（Cycles Per Instruction，简称 CPI）×Clock Cycle Time 

### 性能提升
* 功耗 ~= 1/2 ×负载电容×电压的平方×开关频率×晶体管数量

想要计算得快，一方面，我们要在 CPU 里，同样的面积里面，多放一些晶体管，也就是增加密度，提升**制程**；另一方面，我们要让晶体管“打开”和“关闭”得更快一点，也就是提升主频。而这两者，都会增加功耗，带来**耗电和散热**的问题。

降低电压，功耗平方指数级降低

* 并行优化  
前提：符合 forkjoin 任务模型  
优化计算规律：阿姆达尔定律：优化后的执行时间 = 受优化影响的执行时间 / 加速倍数 + 不受影响的执行时间

* 加速大概率事件：向量与矩阵计算： cpu->gpu->tpu

* 通过流水线提高性能：指令分工

* 通过预测提高性能：分支和冒险、“局部性原理”

# 计算机指令和运算

## 指令集

* 高级语言->汇编语言->机器码
* 汇编代码（ASM，Assembly Language）和机器码之间是一一对应的
* 指令集：算术类、逻辑类、条件分支类、数据传输类（给变量赋值、在内存里读写数据）、无条件跳转（调用函数）

## 寄存器  
逻辑上，我们可以认为，CPU 其实就是由一堆寄存器组成的。而寄存器就是 CPU 内部，由多个触发器（Flip-Flop）或者锁存器（Latches）组成的简单电路。N 个触发器或者锁存器，就可以组成一个 N 位（Bit）的寄存器，能够保存 N 位的数据。比方说，我们用的 64 位 Intel 服务器，寄存器就是 64 位的。触发器和锁存器，其实就是两种不同原理的数字电路组成的逻辑门
### 分类与运行
* PC 寄存器：指令地址寄存器、指令寄存器、条件码寄存器、其他用来存储数据和内存地址的寄存器
* 一个程序执行的时候，CPU 会根据 PC 寄存器里的地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。可以看到，一个程序的一条条指令，在内存里面是连续保存的，也会一条条顺序加载。

## cpu执行：指令封装与复用
* 内存栈：函数间调用，通过压栈帧（返回地址、参数列表）和出栈帧，在指令跳转的过程种，加入了一个“记忆”的功能，能够实现更加丰富和灵活的指令执行流程
* 优化：编译时内联（原因：CPU 需要执行的指令数变少了，根据地址跳转的过程不需要了，压栈和出栈的过程也不用了。缺点：程序占用空间变大），避免栈溢出（减少参数列表或者函数作用域里面的临时变量的占用内存，避免递归层数过深）

## 编译、链接和装载
* C 语言代码，可以通过编译器编译成汇编代码，然后汇编代码再通过汇编器变成 CPU 可以理解的机器码也叫：目标文件（Object File）。再通过链接器（Linker）把多个目标文件以及调用的各种函数库（os相关：系统调用，动态链接库）链接起来，我们才能得到一个可执行文件。
* 第一个部分由编译（Compile）、汇编（Assemble）以及链接（Link）三个阶段组成，生成了一个可执行文件。第二部分，我们通过装载器（Loader）把可执行文件装载（Load）到内存中。CPU 从内存中读取指令和数据，来开始真正执行程序。
* Linux 下，可执行文件和目标文件所使用的都是一种叫 ELF（Execuatable and Linkable File Format）的文件格式，中文名字叫可执行与可链接文件格式
* elf与静态链接机制   
ELF 文件格式把各种信息，分成一个一个的 Section 保存起来。ELF 有一个基本的文件头（File Header），用来表示这个文件的基本属性，比如是否是可执行文件，对应的 CPU、操作系统等等。代码段，数据段，重定位表（Relocation Table），符号表（Symbol Table）。符号表保留了我们所说的当前文件里面定义的函数名称和对应地址的地址簿。

* Windows 的可执行文件格式是一种叫作 PE（Portable Executable Format）的文件格式。
* 装载器：wine、wsl
* 高级语言：Java的类加载是由jvm完成，大致过程为装载-链接-初始化-运行，所以是jvm帮我们屏蔽了操作系统之间的差异。为了加快程序启动速度，一些类会延迟加载，所以jvm中有很多动态链接。

### 程序装载
* 要求
1. 可执行程序加载后占用的内存空间应该是连续的:程序计数器是顺序地一条一条指令执行下去
2. 我们需要同时加载很多个程序，并且不能让程序自己规定在内存中加载的位置（让程序不需要考虑实际的物理内存地址、大小和当前连续分配空间问题）。
* 解决方案：加入一个间接层
1. 内存页映射：虚拟内存地址（Virtual Memory Address 指令里用到的内存地址，对于任何一个程序来说，它看到的都是同样的内存地址）与物理内存地址（Physical Memory Address实际在内存硬件里面的空间地址）映射表。
2. 内存分页： getconf PAGE_SIZE（4096）
3. 内存交换与虚拟内存：分配映射表后可以延迟加载，当cpu发出内存缺页错误（Page Fault，还没有加载或者交换出去在硬盘上），os将对应的页，从存放在硬盘上的虚拟内存里读取出来，加载到物理内存里。

### 动态链接
* 编译出来的共享库文件的指令代码，是地址无关码（Position-Independent Code）。动态代码库内部的变量和函数调用，使用相对地址（Relative Address）。
* 动态链接的解决方案：
1. 程序链接表（Procedure Link Table）里面找要调用的函数。
2. 在动态链接对应的共享库，我们在共享库的 data section 里面，保存了一张全局偏移表（GOT，Global Offset Table）。虽然共享库的代码部分的物理内存是共享的，但是数据部分是各个动态链接它的应用程序里面各加载一份的。所有需要引用当前共享库外部的地址的指令，都会查询 GOT，来找到当前运行程序的虚拟内存里的对应位置。而 GOT 表里的数据，则是在我们加载一个个共享库的时候写进去的。不同的进程，调用同样的 lib.so，各自 GOT 里面指向最终加载的动态链接库里面的虚拟内存地址是不同的。
3. PLT是为了做延迟绑定，如果函数没有实际被调用到，就不需要更新GOT里面的数值。因为很多动态装载的函数库都是不会被实际调用到的。
* **不仅能够做到代码在开发阶段的复用，也能做到代码在运行阶段的复用。**